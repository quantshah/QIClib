<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Documentation - QIC_lib</title>
    <link rel="icon" href="qic.png" type="image/png">
    <meta name="author" content="Titas Chanda"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <meta name="robots" content="noindex">
    <meta name="googlebot" content="noindex">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Quantum Information and Computation library <br> (QIC_lib)</h1>
      <h2 class="project-tagline">A C++11 library for quantum information and computation based on Armadillo</h2>
      <a href="index.html" class="btn">Home</a>
      <a href="documentation.html" class="btn">API Documentation</a>
      <a href="sample.html" class="btn">Sample Codes</a>
      <br>
      <a href="https://github.com/titaschanda/QIC_lib" class="btn">View on GitHub</a>
      <a href="https://github.com/titaschanda/QIC_lib/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/titaschanda/QIC_lib/tarball/master" class="btn">Download .tar.gz</a>

    </section>

    <section class="main-content">
    
      <a name=top></a>  
      <center><h2> API Reference for QIC_lib 0.0.4	
      </h2></center>

      <b>Preamble</b>
      <br>
      
      <tr>
	<td style="text-align: left; vertical-align: top; width: 50%;">
	  <ul>
	    <br>
	    <li>
	      Every functions, classes, or constants in QIC_lib belongs to the <code> namespace qic</code>.
	    </li>
	    <br>
	    <li>
	      First time users may want to have a look on  <a href="sample.html#samples">sample programs</a>.
	    </li>
	    <br>
	    <li>
	      First time users may want to have a look on  <a href="#faq">frequently asked questions</a>.
	    </li>
	    <br>
	    <li>
	      If you discover any bugs or regressions, please <a href="index.html#found-an-issue-or-bug">report them</a>
	    </li>
	    <br>
	    <li>
	      Notes on <a href="#api_additions">API additions</a>
	    </li>
	  </ul>
	</td>
	<td>

	  <br>


	  <b>Overview</b><br>
	  <ul>
	    <li><a href="#classes">Classes and constants</a></li>
	    <li><a href="#functions">Functions</a></li>
	    <li><a href="#discord_func">Discord like functions</a></li>
	  </ul>
	  <br>


	  <a name="classes"></a>
	  <b>Classes and constants</b><br>
	  <ul>
	    <table>
	      <tbody>
		<tr><td><a href="#eps"> _precision::eps     </td><td>  </td><td> Precision for floating point arithmetic</td></tr>
		<tr><td><a href="#init"> Init     </td><td>  </td><td> Class for library initialization</td></tr>
		<tr><td><a href="#states"> STATES&lttype&gt, states, fstates  </td><td>  </td><td> Several predefined basis states, projectors and operators</td></tr>
		<tr><td><a href="#func"> Func&lttype&gt, func, funcf  </td><td>  </td><td> Several predefined functions to be used with <a href = #funcm_sym><code>funcm_sym</code></a> or <a href = #funcm_gen><code>funcm_gen</code></a>
		</td></tr>
		
	      </tbody>
	    </table>
	  </ul>
	  <br>



	  <a name="functions"></a>
	  <b>Functions</b><br>
	  <ul>
	    <table>
	      <tbody>
		<tr><td><a href="#is_H"> is_H  </td><td>  </td><td> Hermiticity check</td></tr>
		<tr><td><a href="#is_U"> is_U  </td><td>  </td><td> Unitarity check</td></tr>
		<tr><td><a href="#is_pure"> is_pure  </td><td>  </td><td>Check purity of a density matrix</td></tr>
		<tr><td><a href="#is_valid_state"> is_valid_state  </td><td>  </td><td> Check whether the matrix represents a valid quantum state</td></tr>
		<tr><td><a href="#is_equal"> is_equal  </td><td>  </td><td>Check whether two matrices are equal</td></tr>
		<tr><td><a href="#range"> range  </td><td>  </td><td> Similar to Python's range() function. Useful in range-based for loops</td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td><a href="#TrX"> TrX  </td><td>  </td><td> Partial trace</td></tr>
		<tr><td><a href="#Tx"> Tx  </td><td>  </td><td> Partial transpose</td></tr>
		<tr><td><a href="#sysperm"> sysperm  </td><td>  </td><td> Permute subsystems of a quantum state</td></tr>
		<tr><td><a href="#sqrtm_sym"> sqrtm_sym  </td><td>  </td><td>Principal square root of matrix for real symmetric or Hermitian matrices</td></tr>
		<tr><td><a href="#sqrtm_gen"> sqrtm_gen  </td><td>  </td><td>Principal square root of matrix for general square matrices</td></tr>
		<tr><td><a href="#powm_sym"> powm_sym  </td><td>  </td><td>Matrix power for real symmetric or Hermitian matrices</td></tr>
		<tr><td><a href="#powm_gen"> powm_gen  </td><td>  </td><td>Matrix power for general square matrices</td></tr>
		<tr><td><a href="#expm_sym"> expm_sym  </td><td>  </td><td>Matrix exponential for real symmetric or Hermitian matrices</td></tr>
		<tr><td><a href="#expm_gen"> expm_gen  </td><td>  </td><td>Matrix exponential for general square matrices</td></tr>
		<tr><td><a href="#funcm_sym"> funcm_sym  </td><td>  </td><td>Matrix function for real symmetric or Hermitian matrices</td></tr>
		<tr><td><a href="#funcm_gen"> funcm_gen  </td><td>  </td><td>Matrix function for general square matrices</td></tr>
		<tr><td><a href="#tensor"> tensor  </td><td>  </td><td> Tensor product of arbitrary no. of  matrices</td></tr>
		<tr><td><a href="#tensor_pow"> tensor_pow  </td><td>  </td><td>Tensor product power</td></tr>	
		<tr><td><a href="#dsum"> dsum  </td><td>  </td><td> Direct sum of arbitrary no. of  matrices</td></tr>
		<tr><td><a href="#dsum_pow"> dsum_pow  </td><td>  </td><td>Direct sum power</td></tr>		
		<tr><td><a href="#absm"> absm  </td><td>  </td><td>Matrix absolute value of a square matrix</td></tr>
		<tr><td><a href="#schatten"> schatten  </td><td>  </td><td>Schatten p-norm of a matrix</td></tr>
		<tr><td><a href="#conv_to_pure"> conv_to_pure  </td><td>  </td><td>Convert density matrix of a pure state to a column vector</td></tr>
		<tr><td><a href="#conv_to_HS"> conv_to_HS  </td><td>  </td><td>Convert 2-qubit density matrix from the standard basis to the Hilbert-Schmidt basis </td></tr>
		<tr><td><a href="#conv_to_std"> conv_to_std  </td><td>  </td><td>Convert 2-qubit density matrix from the Hilbert-Schmidt basis back to the standard basis</td></tr>

		<tr><td><a href="#mket"> mket  </td><td>  </td><td> Multipartite qudit pure state </td></tr>
		<tr><td><a href="#mproj"> mproj  </td><td>  </td><td> Multipartite qudit projector </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td><a href="#entropy"> entropy  </td><td>  </td><td>von Neumann entropy of a quantum state</td></tr>
		<tr><td><a href="#shannon"> shannon  </td><td>  </td><td>Shannon entropy of a probability distribution</td></tr>
		<tr><td><a href="#renyi"> renyi  </td><td>  </td><td>Renyi entropy of a quantum state</td></tr>
		<tr><td><a href="#renyi_prob"> renyi_prob  </td><td>  </td><td>Renyi entropy of a probability distribution</td></tr>
		<tr><td><a href="#tsallis"> tsallis  </td><td>  </td><td>Tsallis entropy of a quantum state</td></tr>
		<tr><td><a href="#tsallis_prob"> tsallis_prob  </td><td>  </td><td>Tsallis entropy of a probability distribution</td></tr>
		<tr><td><a href="#mutual_info"> mutual_info  </td><td>  </td><td>Quantum mutual information between 2 subsystems of a quantum state</td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td><a href="#entanglement"> entanglement  </td><td>  </td><td>Entanglement entropy of a pure quantum state</td></tr>
		<tr><td><a href="#neg"> neg  </td><td>  </td><td> Negativity of a quantum state</td></tr>
		<tr><td><a href="#log_neg"> log_neg  </td><td>  </td><td>Logarithmic negativity of a quantum state</td></tr>
		<tr><td><a href="#concurrence"> concurrence  </td><td>  </td><td>Concurrence of a two-qubit quantum state</td></tr>
		<tr><td><a href="#EoF"> EoF  </td><td>  </td><td>Entanglement of formation of a two-qubit quantum state</td></tr>
		<tr><td><a href="#ent_check_CMC"> ent_check_CMC  </td><td>  </td><td> Check if a bipartite state is entangled or not 
		    (based on covariant matrix formulation)</td></tr>
		<tr><td><a href="#schmidt"> schmidt  </td><td>  </td><td> Schmidt decomposition of a bipartite pure state</td></tr>
		<tr><td><a href="#schmidt_base"> schmidtA, schmidtB, schmidtAB
		      schmidtA_full, schmidtB_full, schmidtAB_full </td><td>  </td><td> Schmidt vectors of a bipartite pure state</td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td><a href="#HS_dist"> HS_dist  </td><td>  </td><td>Hilbert-Schmidt distance between two density matrices</td></tr>	      
		<tr><td><a href="#tr_dist"> tr_dist  </td><td>  </td><td>Trace distance between two density matrices</td></tr>
		<tr><td><a href="#HS_dist"> bures_dist  </td><td>  </td><td>Bures distance between two density matrices</td></tr>
		<tr><td><a href="#HS_dist"> fidelity  </td><td>  </td><td>Fidelity between two density matrices</td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td>  </td><td>  </td><td> </td></tr>
		<tr><td><a href="#apply"> apply  </td><td>  </td><td>Apply a gate to a quantum state</td></tr>	      
		<tr><td><a href="#apply_ctrl"> apply_ctrl  </td><td>  </td><td>Apply a controlled-gate to a quantum state</td></tr>



	      </tbody>
	    </table>
	  </ul>
	  <a href="#top">Go to top</a>
	  <br><br>



	  <a name="discord_func"></a>
	  <b>Discord like functions</b><br>
	  <ul>
	    <li> <b>Note:</b> These functions depend on <a href = "http://ab-initio.mit.edu/wiki/index.php/NLopt">NLopt</a>. </li> <br>
	    <table>
	      <tbody>
		<tr><td><a href="#discord"> discord  </td><td>  </td><td> Quantum discord of a  density matrix where measurement is done over a qubit system</td></tr>
		<tr><td><a href="#discord3"> discord3  </td><td>  </td><td> Quantum discord of a  density matrix where measurement is done over a qutrit system</td></tr>
		<tr><td><a href="#discord_reg"> discord_reg  </td><td>  </td><td>Constrained regular quantum discord of a  density matrix where measurement is done over a qubit system</td></tr>
		<tr><td><a href="#discord3_reg"> discord3_reg  </td><td>  </td><td> Constrained regular quantum discord of a  density matrix where measurement is done over a qutrit system</td></tr>

		<tr><td><a href="#deficit"> deficit  </td><td>  </td><td> Quantum work deficit of a density matrix where measurement is done over a qubit system</td></tr>
		<tr><td><a href="#deficit3"> deficit3  </td><td>  </td><td> Quantum work deficit of a  density matrix where measurement is done over a qutrit system</td></tr>
		<tr><td><a href="#deficit_reg"> deficit_reg  </td><td>  </td><td>Constrained regular quantum work deficit of a  density matrix where measurement is done over a qubit system</td></tr>
		<tr><td><a href="#deficit3_reg"> deficit3_reg  </td><td>  </td><td> Constrained regular quantum work deficit of a  density matrix where measurement is done over a qutrit system</td></tr>



	      </tbody>
	    </table>
	  </ul>
	  <a href="#top">Go to top</a>
	  <br><br>





	  <hr><hr>

	  In this documentation the <i>mat</i>, <i>cx_mat</i>, <i>vec</i>, and <i>cx_vec</i>  type is used for convenience. 
	  But every function should also work with <i>float</i> counterparts, like <i>fmat</i>, <i>cx_fmat</i>, <i>fvec</i>, and <i>cx_fvec</i>.

	  <hr><hr>

	  <h3>Classes and constants</h3>
	  <hr> <br>


	  <a name=eps></a>
	  <b>_precision::eps</b><br><br>
	  <ul>
	    <li> Precision for floating point arithmetic. </li><br> 
	    <li>Every <code>double</code> <i>less than</i> <code>_precision::eps&lt;double&gt;::value</code> will be treated as zero.</li><br>
	    <li>Every <code>float</code> <i>less than</i> <code>_precision::eps&lt;float&gt;::value</code> will be treated as zero.</li><br>
	    <li> Default value for <code>_precision::eps&lt;double&gt;::value</code> is <code>1e-12</code>, and <code>_precision::eps&lt;float&gt;::value</code> is <code>1e-6</code>. It can be changed by editing <code>include/QIC_lib_bits/class/constants.hpp</code> file.</li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=init></a>
	  <b>Init</b><br><br>
	  <ul>
	    <li>  Class for library initialization.</li><br>
	    <li> Used by <code>static const Init& init = Init::get_instance();</code>. <br> See <code>include/QIC_lib_bits/class/init.hpp</code> file for details. </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=states></a>
	  <b>STATES&lttype&gt<br> states <br> fstates</b><br><br>
	  <ul>
	    <li> Several predefined <i> complex </i> basis states, projectors and operators. <code>type</code> can be either <code>double</code> or <code>float</code>.</li><br>
	    <li> Used by <code>static const STATES&ltdouble&gt& states  = STATES&ltdouble&gt::get_instance();</code> and <br> 
	      <code>static const STATES&ltfloat&gt& fstates  = STATES&ltfloat&gt::get_instance();</code>. <br>
	      See <code>include/QIC_lib_bits/class/init.hpp</code> file for details. </li><br>

	    <li> <code>states.S</code> returns <a href = "http://arma.sourceforge.net/docs.html#field"><code>field</code></a> of Pauli matrices (<code>const cx_mat</code>). <code>states.S(0)</code>, <code>states.S(1)</code>, <code>states.S(2)</code>, and <code>states.S(3)</code> are respectively <i>I<sub>2x2</sub></i>, <i> &sigma;<sub>x</sub></i>, <i> &sigma;<sub>y</sub></i>, and <i> &sigma;<sub>z</sub></i>.</li><br>
	    <li> <code>states.basis2</code> returns <a href = "http://arma.sourceforge.net/docs.html#field"><code>field</code></a> of 2-dimensional basis vectors (<code>const cx_vec</code>). <code>states.basis(0,i)</code> and <code>states.basis(1,i)</code> are respectively |0&gt and |1&gt in <i>i</i> direction ( <i>i = 0, 1, 2, 3 </i>). <code>states.proj2</code>
	      returns corresponding projectors (<code>const cx_mat</code>).</li><br>
	    <li> <code>states.basis3</code> returns <a href = "http://arma.sourceforge.net/docs.html#field"><code>field</code></a> of 3-dimensional basis vectors (<code>const cx_vec</code>). <code>states.basis(0,i)</code>, <code>states.basis(1,i)</code> and <code>states.basis(2,i)</code> are respectively |0&gt, |1&gt and |2&gt in <i>i</i> direction ( <i>i = 0, 1, 2, 3 </i>). <code>states.proj3</code> returns corresponding projectors (<code>const cx_mat</code>).</li><br>
	    <li> <b>Note:</b> You cannot take a copy of the whole <code>STATES&lttype&gt</code> class, but you can take reference to <code>const</code>. For this use <code>const STATES&ltdouble&gt& SOMENAME  = STATES&ltdouble&gt::get_instance();</code>. <br>
	      For each member variables, like <code>S</code> or <code>proj3</code> etc., you can either take a copy or reference to <code>const</code> (See the following example).</li><br> 

	    <li> Example:
	      <pre>
		const cx_mat& S1 = states.S(1); // \sigma_x matrix, take reference
		cx_mat S2 = states.S(2); // \sigma_y matrix, take a copy

		const cx_vec& plus = states.basis2(0,1); // |+&gt state
		const cx_mat& proj_plus = states.proj2(0,1); // |+&gt&lt+| projector

		const cx_vec& U = states.basis3(0,3); // 1st eigenvector of 
                //Spin S_z operator in 3-dim
		const cx_mat& M = states.basis3(1,3); // 2nd eigenvector of 
                //Spin S_z operator in 3-dim
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name=func></a>
	  <b>Func&lttype&gt<br> func <br> funcf</b><br><br>
	  <ul>
	    <li> Class with several predefined static member functions to be used with <a href = "#funcm_sym"><code>funcm_sym</code></a> or <a href = "#funcm_gen"><code>funcm_gen</code></a>.</li><br>
	    <li> <code>func</code> is an alias for <code>Func&lt;double&gt;</code> and <code>funcf</code> is an alias for <code>Func&lt;float&gt;</code>.</li><br>
	    <li> Every member function takes one <i>complex</i> type and returns one <i>complex</i> type.</li><br>
	    <li> List of member functions:
	      <ul>
		<li> func::sin</li>
		<li> func::cos</li>
		<li> func::tan</li><br>
		<li> func::asin</li>
		<li> func::acos</li>
		<li> func::atan</li><br>
		<li> func::sinh</li>
		<li> func::cosh</li>
		<li> func::tanh</li><br>
		<li> func::asinh</li>
		<li> func::acosh</li>
		<li> func::atanh</li><br>
		<li> func::sqrt</li>
		<li> func::log</li>
		<li> func::log2</li><br>
		<li> func::real</li>
		<li> func::imag</li>
		<li> func::norm</li><br>
	      </ul>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>







	  <hr><hr>
	  
	  <h3>Functions</h3>
	  <hr> <br>


	  
	  <a name=is_H></a>
	  <b>is_H(A)<br>is_H(A,atol,rtol)</b><br><br>
	  <ul>
	    <li> Hermiticity check. Returns <code>true</code> if <code>A</code> is real symmetric or Hermitian, else <code>false</code>.</li><br>
	    <li> <code>atol</code> and <code>rtol</code> are optional, by default <code>atol = 1e-2 * _precision::eps&lt;POD_TYPE&gt;::value</code> and <code>rtol = 10 * _precision::eps&lt;POD_TYPE&gt;::value</code>. <code>POD_TYPE</code> is either <code>double</code> or <code>float</code>.</li>
	    
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>
	  



	  <a name=is_U></a>
	  <b>is_U(A)<br>is_U(A,atol,rtol)</b><br><br>
	  <ul>
	    <li> Unitarity check. Returns <code>true</code> if <code>A</code> is real orthogonal or unitary, else <code>false</code>.</li><br>
	    <li> <code>atol</code> and <code>rtol</code> are optional, by default <code>atol = 1e-2 * _precision::eps&lt;POD_TYPE&gt;::value</code> and <code>rtol = 10 * _precision::eps&lt;POD_TYPE&gt;::value</code>. <code>POD_TYPE</code> is either <code>double</code> or <code>float</code>.</li>	    
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>
	  



	  <a name=is_pure></a>
	  <b>is_pure(A)<br>is_pure(A,check_norm=true)<br>is_pure(A,check_norm=ture,tol)</b><br><br>
	  <ul>
	    <li> Check purity of a density matrix. Returns <code>true</code> if <code>A</code> is a pure state, else <code>false</code>.</li><br>
	    <li> <code>check_norm</code> and <code>tol</code> are optional. By default <code>check_norm = true</code> and normalisation of the state will not be checked and <code>tol = _precision::eps&lt;POD_TYPE&gt;::value</code>, <code>POD_TYPE</code> is either <code>double</code> or <code>float</code>.</li>
	    
	  </ul>
	  <a href="#top">Go to top</a>
	  
	  
	  <hr><br>
	  


	  <a name=is_valid_state></a>
	  <b>is_valid_state(A)<br>is_valid_state(A,tol)</b><br><br>
	  <ul>
	    <li> Check whether the matrix or vector represents a valid quantum state. Returns <code>true</code> if <code>A</code> is a valid quantum state, else <code>false</code>.</li><br>
	    <li> <code>tol</code> is optional, by default <code>tol = _precision::eps&lt;POD_TYPE&gt;::value</code>, <code>POD_TYPE</code> is either <code>double</code> or <code>float</code>.</li><br>
	    <li> Note: Normalisation will always be checked.</li>
	  </ul>
	  <a href="#top">Go to top</a>
	  
	  
	  <hr><br>



	  <a name=is_equal></a>
	  <b>is_equal(A,B)<br>is_equal(A,B,typecheck=false)<br>is_equal(A,B,typecheck=false,atol,rtol)</b><br><br>
	  <ul>
	    <li> Check whether two matrices are equal. Returns <code>true</code> if <code>A</code> and <code>B</code> are element-wise equal, else <code>false</code>.</li><br>
	    <li> <code>typecheck</code> is optional. By default <code>typecheck=false</code>, and element types of <code>A</code> and <code>B</code> will not be checked.
	    <li> <code>atol</code> and <code>rtol</code> are optional, by default <code>atol = 1e-2 * _precision::eps&lt;POD_TYPE&gt;::value</code> and <code>rtol = 10 * _precision::eps&lt;POD_TYPE&gt;::value</code>. <code>POD_TYPE</code> is either <code>double</code> or <code>float</code>.</li>	 
	    
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>


	  <a name=range></a>
	  <b>range(stop)<br>range(start,stop)<br>range(start,stop,step)</b><br><br>
	  <ul>
	    <li> Similar to Python's <code>range()</code> function. Useful in range-based <code>for</code> loops. Returns <code>std::vector</code> of arithmetic (floating point or integral types) values, from (and including) <code>start</code> to (and excluding) <code>stop</code> with step-size equal to <code>step</code>.</li><br>
	    <li> <code>start</code> and <code>step</code> are optional, by default <code>start = 0</code> and <code>step = 1</code>.</li><br>
	    <li> Example:
	      <pre>
		for(auto&& i : range(10))
		{
		// i from 0 to 9
		//do something
		}
		
		std::vector&lt;int&gt; R1 = range(2,10,2); 
		std::vector&lt;double&gt; R2 = range(10,-1.5,-0.5);
	      </pre>
	    </li>

	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>




	  <a name=TrX></a>
	  <b>TrX(A,subsys) <br> TrX(A,subsys,dim) </b><br><br>
	  <ul>
	    <li> Partial trace of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices of traced out subsystems.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		cx_mat B = randn&lt;cx_mat&gt;(12,12); // 12x12 matrix
		B *= B.t(); // make hermitian
		B /= trace(B); //normalise

                // trace out 2nd and 3rd party
                cx_mat A1 = TrX(A,{2,3}); // all dim are 2, total 3 parties

                // trace out 2nd and 3rd party
                cx_mat B1 = TrX(B,{2,3},{2,3,2}); // explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>



	  <a name=Tx></a>
	  <b>Tx(A,subsys) <br> Tx(A,subsys,dim) </b><br><br>
	  <ul>
	    <li> Partial transpose of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices of transposed subsystems.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		cx_mat B = randn&lt;cx_mat&gt;(12,12); // 12x12 matrix
		B *= B.t(); // make hermitian
		B /= trace(B); //normalise

                // transpose 2nd and 3rd party
                cx_mat A1 = Tx(A,{2,3}); // all dim are 2, total 3 parties

                // transpose 2nd and 3rd party
                cx_mat B1 = Tx(B,{2,3},{2,3,2}); // explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>



	  <a name=sysperm></a>
	  <b>sysperm(A,subsys) <br> sysperm(A,subsys,dim) </b><br><br>
	  <ul>
	    <li> Permute subsystems of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices of permuted subsystems.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		cx_mat B = randn&lt;cx_mat&gt;(12,12); // 12x12 matrix
		B *= B.t(); // make hermitian
		B /= trace(B); //normalise

                // permute 2nd and 3rd party
                cx_mat A1 = sysperm(A,{1,3,2}); // all dim are 2, total 3 parties

                // permute 2nd and 3rd party
                cx_mat B1 = sysperm(B,{1,3,2},{2,3,2}); // explicitly writen dimensions
                // for B1, dim = {2,2,3} 
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>



	  <a name=sqrtm_sym></a>
	  <b>sqrtm_sym(A)</b><br><br>
	  <ul>
	    <li>Principal square root of matrix for real symmetric or Hermitian matrices.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Due to generality, always returns <i>complex</i> matrices, even for <i>positive real</i> matrices.</li><br>
	    <li> Note: <code>sqrtm_sym</code> is faster than <a href = "#sqrtm_gen"><code>sqrtm_gen</code></a>. For real symmetric or Hermitian matrices always use
	      <code>sqrtm_sym</code>.</li><br>
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5,5);
		A *= A.t(); // make hermitian
		
		mat B = randn&lt;mat&gt;(5,5);
		B *= B.t(); // make hermitian
		
		cx_mat sqrtA = sqrtm_sym(A);

		cx_mat sqrtB = sqrtm_sym(B);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>



	  <a name=sqrtm_gen></a>
	  <b>sqrtm_gen(A)</b><br><br>
	  <ul>
	    <li>Principal square root of matrix for general square matrices.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Due to generality, always returns <i>complex</i> matrices, even for <i>positive real</i> matrices.</li><br>
	    <li> Note: <a href = "#sqrtm_sym"><code>sqrtm_sym</code></a> is faster than <code>sqrtm_gen</code>. For real symmetric or Hermitian matrices always use
	      <a href = "#sqrtm_sym"><code>sqrtm_sym</code></a>.</li><br>
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5,5);
		
		mat B = randn&lt;mat&gt;(5,5);
		
		cx_mat sqrtA = sqrtm_gen(A);

		cx_mat sqrtB = sqrtm_gen(B);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>



	  <a name=powm_sym></a>
	  <b>powm_sym(A,n)</b><br><br>
	  <ul>
	    <li>Matrix power for real symmetric or Hermitian matrices.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>). <code>n</code> can be any type of scaler, like <code>double</code>, <code>complex&lt;double&gt;</code>, <code>int</code> etc.</li><br>
	    <li> Due to generality, always returns <i>complex</i> matrices (if <code>n</code> is not <i>integer type</i>), even for <i>positive real</i> matrices.
	      If <code>n</code> is of <i>integer type</i> matrix element type will be preserved.</li><br>
	    <li> Note: <code>powm_sym</code> is faster than <a href = "#powm_gen"><code>powm_gen</code></a>. For real symmetric or Hermitian matrices always use
	      <code>powm_sym</code>.</li><br>
	    <li> Example:

	      <pre>
		mat A = randn&lt;mat&gt;(5,5);
		A *= A.t(); // make hermitian
		
		mat A_3 = powm_sym(A,3);

		cx_mat A_3.14 = powm_sym(A,3.14);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=powm_gen></a>
	  <b>powm_gen(A,n)</b><br><br>
	  <ul>
	    <li>Matrix power for general square matrices.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>). <code>n</code> can be any type of scaler, like <code>double</code>, <code>complex&lt;double&gt;</code>, <code>int</code> etc.</li><br>
	    <li> Due to generality, always returns <i>complex</i> matrices (if <code>n</code> is not <i>integer type</i>), even for <i>positive real</i> matrices.
	      If <code>n</code> is of <i>integer type</i> matrix element type will be preserved.</li><br>
	    <li> Note: <a href = "#powm_sym"><code>powm_sym</code></a> is faster than <code>powm_gen</code>. For real symmetric or Hermitian matrices always use
	      <a href = "#powm_sym"><code>powm_sym</code></a>.</li><br>
	    <li> Example:

	      <pre>
		mat A = randn&lt;mat&gt;(5,5);
		
		mat A_3 = powm_gen(A,3);

		cx_mat A_3.14 = powm_gen(A,3.14);  
  	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>



	  <a name=expm_sym></a>
	  <b>expm_sym(A)<br>expm_sym(A,n)</b><br><br>
	  <ul>
	    <li>Matrix exponential for real symmetric or Hermitian matrices.<code>expm_sym(A,n)</code> calculates <i>exp(n*A)</i>.</li><br>
	    <li> <code>A</code> has to be a square real symmetric or Hermitian matrix (<code>mat</code> or <code>cx_mat</code>). <code>n</code> can be any type of scaler, like <code>double</code>, <code>complex&lt;double&gt;</code>, <code>int</code> etc.</li><br>
	    <li> Note: <code>expm_sym</code> is slower but more accurate than <a href = "#expm_gen"><code>expm_gen</code></a> or <a href="http://arma.sourceforge.net">Armadillo's</a> <a href = "http://arma.sourceforge.net/docs.html#expmat"><code>expmat</code></a>. </li><br>
	    <li> Example:
	      <pre>
		mat A = randn&lt;mat&gt;(5,5);
		A *= A.t(); // make hermitian
		
		mat A_e = expm_sym(A);

		complex&lt;double&gt; I (0.0,1.0);
		cx_mat AI_e = expm_sym(A,I);
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>







	  <hr><br>



	  <a name=expm_gen></a>
	  <b>expm_gen(A)</b><br><br>
	  <ul>
	    <li>Matrix exponential for general square matrices.    </li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>). </li><br>
	    <li> Note: <code>expm_gen</code> is basically same as <a href="http://arma.sourceforge.net">Armadillo's</a> <a href = "http://arma.sourceforge.net/docs.html#expmat"><code>expmat</code></a>, and only to be used with older versions of <a href="http://arma.sourceforge.net">Armadillo</a>. </li><br>
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5,5);
		
		cx_mat A_e = expm_gen(A);

		complex&lt;double&gt; I (0.0,1.0);
		cx_mat AI_e = expm_gen(I*A);
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>



	  <a name=funcm_sym></a>
	  <b>funcm_sym(A,function pointer)<br>funcm_sym(A,functor)<br>funcm_sym(A,lambda function)</b><br><br>
	  <ul>
	    <li><a href = "https://en.wikipedia.org/wiki/Matrix_function">Matrix function</a> for real symmetric or Hermitian matrices.   </li><br>
	    <li> <code>A</code> has to be a square real symmetric or Hermitian matrix (<code>mat</code> or <code>cx_mat</code>). <i>function pointer</i>, <i>functor</i> or <i>lambda function</i> has to take one <i>complex</i> type and return one <i>complex</i> type.</li><br>
	    <li> If you want to use standard <i>complex</i> functions, use static member functions of <a href="#func"><code>Func&lt;type&gt;</code></a> class.</li><br>
	    <li> Note: <code>funcm_sym</code> is faster than <a href = "#funcm_gen"><code>funcm_gen</code></a>. For real symmetric or Hermitian matrices always use
	      <code>funcm_sym</code>. </li><br>
	    <li> Note: If you want to transform the matrix element-wise, use <a href="http://arma.sourceforge.net/docs.html#transform"><code>.transform</code></a> instead.</li><br>
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5,5);
		A *= A.t(); // make hermitian
		
		//define a lambda function
		auto sinm = [](complex&lt;double&gt; a){return std::sin(a);};

		cx_mat A_sin = funcm_sym(A,sinm); // calculate sin(A)

		cx_mat A_sin2 = funcm_sym(A,func::sin); // same as A_sin, 
		//using <code>Func&lt;type&gt;</code> class
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>



	  <a name=funcm_gen></a>
	  <b>funcm_gen(A,function pointer)<br>funcm_gen(A,functor)<br>funcm_gen(A,lambda function)</b><br><br>
	  <ul>
	    <li><a href = "https://en.wikipedia.org/wiki/Matrix_function">Matrix function</a> for general square matrices.   </li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>). <i>function pointer</i>, <i>functor</i> or <i>lambda function</i> has to take one <i>complex</i> type and return one <i>complex</i> type.</li><br>
	    <li> If you want to use standard <i>complex</i> functions, use static member functions of <a href="#func"><code>Func&lt;type&gt;</code></a> class.</li><br>
	    <li> Note: <a href = "#funcm_sym"><code>funcm_sym</code></a> is faster than <code>funcm_gen</code>. For real symmetric or Hermitian matrices always use
	      <a href = "#funcm_sym"><code>funcm_sym</code></a>.</li><br>
	    <li> Note: If you want to transform the matrix element-wise, use <a href="http://arma.sourceforge.net/docs.html#transform"><code>.transform</code></a> instead.</li><br>
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5,5);
		
		//define a lambda function
		auto sinm = [](complex&lt;double&gt; a){return std::sin(a);}; 

		cx_mat A_sin = funcm_gen(A,sinm); // calculate sin(A)

		cx_mat A_sin2 = funcm_gen(A,func::sin); // same as A_sin, 
		// using <code>Func&lt;type&gt;</code> class
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>


	  <a name=tensor></a>
	  <b>tensor(A,B,...)</b><br><br>
	  <ul>
	    <li>Tensor product of arbitrary no. of matrices <code>A,B,...</code>.   </li><br>
	    <li> Can also take <code>std::vector</code> and <a href = "http://arma.sourceforge.net/docs.html#field"><code>field</code></a> of matrices.</li><br>
	    
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5,5); //complex matrix
		cx_mat B = randn&lt;cx_mat&gt;(4,4); //complex matrix
		cx_mat C = randn&lt;cx_mat&gt;(3,3); //complex matrix
		mat D = randn&lt;mat&gt;(6,6); //real matrix
		
		cx_mat T1 = tensor(A,B,C,D); // tensor product of A,B,C,D 

		std::vector&lt;cx_mat&gt; V = {A,B,C};
		cx_mat T2 = tensor(V); // tensor product of A,B,C
		
		cx_mat T3 = tensor({A,B,C}); // same as above  
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name=tensor_pow></a>
	  <b>tensor_pow(A,n)</b><br><br>
	  <ul>
	    <li>Tensor product power of a matrix.   </li><br>
	    <li>Returns <i>A <sup>&otimes;n</sup></i> .</li>
	    
	  </ul>
	  <a href="#top">Go to top</a>







	  
	  <hr><br>


	  <a name=dsum></a>
	  <b>dsum(A,B,...)</b><br><br>
	  <ul>
	    <li>Direct sum of arbitrary no. of matrices <code>A,B,...</code>.   </li><br>
	    <li> Can also take <code>std::vector</code> and <a href = "http://arma.sourceforge.net/docs.html#field"><code>field</code></a> of matrices.</li><br>
	    
	    <li> Example:

	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(5,5); 
		cx_mat B = randn&lt;cx_mat&gt;(4,4); 
		cx_mat C = randn&lt;cx_mat&gt;(3,3); 
		cx_mat D = randn&lt;cx_mat&gt;(6,6); 
		
		cx_mat T1 = dsum(A,B,C,D);  

		std::vector&lt;cx_mat&gt; V = {A,B,C,D};
		cx_mat T2 = dsum(V); 
		
		cx_mat T3 = dsum({A,B,C});  
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name=dsum_pow></a>
	  <b>dsum_pow(A,n)</b><br><br>
	  <ul>
	    <li>Direct sum power of a matrix.   </li><br>
	    <li>Returns <i>A <sup>&oplus;n</sup></i> .</li>
	    
	  </ul>
	  <a href="#top">Go to top</a>
















	  <hr><br>


	  <a name=absm></a>
	  <b>absm(A)</b><br><br>
	  <ul>
	    <li>Matrix absolute value of a square matrix.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li>Returns <code>sqrtm_sym(rho.t()*rho)</code>.</li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=schatten></a>
	  <b>schatten(A)</b><br><br>
	  <ul>
	    <li>Schatten p-norm of a matrix.</li><br>
	    <li> <code>p</code> has to be greater than equal to <i>0</i>.</li><br>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=conv_to_pure></a>
	  <b>conv_to_pure(A)</b><br><br>
	  <ul>
	    <li>Convert density matrix of a pure state to a column vector.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> If <code>A</code> is a column vector, then it is returned back. </li><br>
	    <li> If <code>A</code> is not a pure state, then eigenvector corresponding to highest eigenvalue is returned. To make sure use <a href="#is_pure"><code>is_pure</code></a> function.</li><br>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=conv_to_HS></a>
	  <b>conv_to_HS(A)</b><br><br>
	  <ul>
	    <li>Convert 2-qubit density matrix from the standard basis to the Hilbert-Schmidt basis.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) of 4x4.</li><br>
	    <li> Always returns a real matrix.</li><br>
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>


	  <a name=conv_to_std></a>
	  <b>conv_to_std(A)</b><br><br>
	  <ul>
	    <li>Convert 2-qubit density matrix from the Hilbert-Schmidt basis to the standard basis.</li><br>
	    <li> <code>A</code> has to be a real square matrix (<code>mat</code>) of 4x4.</li><br>
	    <li> Always returns a complex matrix.</li><br>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>


	  <a name=mket></a>
	  <b>mket(mask) <br>
	    mket&lt;element type&gt;(mask) <br> 
	    mket(mask,dim) <br>
	    mket&lt;element type&gt;(mask,dim)<br> </b><br><br>
	  <ul>
	    <li>Create multipartite qubit pure state according to <i>mask</i> <code>uvec</code> (See following example).</li><br>
	    <li> <code>element type</code> is optional, by default it is <code>complex&lt;double&gt;</code>. It specifies the element type of returned column vector.</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li>Example:
	      <pre>
		cx_vec A = mket({0,0,1}); // |001&gt; state
		// each subsystem is qubit

		vec B = mket&lt;double&gt;({0,0,1}); // same a above
		// but real vector returned
		
		vec C = mket&lt;double&gt;({0,0,1},2); // same a above
		
		cx_vec D = mket({0,2,1},{2,3,2}); //|021&gt; state
		// 1st and 3rd party are qubit
		// 2nd one is qutrit

		vec E = mket&lt;double&gt;({0,2,1},{2,3,2}); //same as above
		// but real vector returned
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>









	  <hr><br>


	  <a name=mproj></a>
	  <b>mproj(mask) <br>
	    mproj&lt;element type&gt;(mask) <br> 
	    mproj(mask,dim) <br>
	    mproj&lt;element type&gt;(mask,dim)<br> </b><br><br>
	  <ul>
	    <li>Create multipartite qubit projectors according to <i>mask</i> <code>uvec</code> (See following example).</li><br>
	    <li> <code>element type</code> is optional, by default it is <code>complex&lt;double&gt;</code>. It specifies the element type of returned column vector.</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li>Example:
	      <pre>
		cx_mat A = mproj({0,0,1}); // |001&gt;&lt;001| projector
		// each subsystem is qubit

		mat B = mproj&lt;double&gt;({0,0,1}); // same a above
		// but real matrix returned
		
		mat C = mproj&lt;double&gt;({0,0,1},2); // same a above
		
		cx_mat D = mproj({0,2,1},{2,3,2}); //|021&gt;&lt;021| projector
		// 1st and 3rd party are qubit
		// 2nd one is qutrit

		mat E = mproj&lt;double&gt;({0,2,1},{2,3,2}); //same as above
		// but real matrix returned
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>








	  <hr><br>


	  <a name=entropy></a>
	  <b>entropy(A)</b><br><br>
	  <ul>
	    <li>von Neumann entropy of a quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> If <code>A</code> is a column vector, then always zero is returned. </li>
	  </ul>
	  <a href="#top">Go to top</a>







	  <hr><br>


	  <a name=shannon></a>
	  <b>shannon(V)</b><br><br>
	  <ul>
	    <li>Shannon entropy of a probability distribution.</li><br>
	    <li> <code>V</code>  has to be a positive real column vector (<code>vec</code>) or <code>std::vector</code> of positive real numbers.</li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>




	  <a name=renyi></a>
	  <b>renyi(A,a)</b><br><br>
	  <ul>
	    <li>Renyi entropy of a quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>), and <code>a</code> has to to greater than or equal to zero.</li><br>
	    <li> If <code>A</code> is a column vector, then always zero is returned. </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>


	  <a name=renyi_prob></a>
	  <b>renyi_prob(V,a)</b><br><br>
	  <ul>
	    <li>Renyi entropy of a probability distribution.</li><br>
	    <li> <code>V</code>  has to be a positive real column vector (<code>vec</code>) or <code>std::vector</code> of positive real numbers, and <code>a</code> has to to greater than or equal to zero.</li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>




	  <a name=tsallis></a>
	  <b>tsallis(A,a)</b><br><br>
	  <ul>
	    <li>Tsallis entropy of a quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>), and <code>a</code> has to to greater than or equal to zero.</li><br>
	    <li> If <code>A</code> is a column vector, then always zero is returned. </li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>


	  <a name=tsallis_prob></a>
	  <b>tsallis_prob(V,a)</b><br><br>
	  <ul>
	    <li>Tsallis entropy of a probability distribution.</li><br>
	    <li> <code>V</code>  has to be a positive real column vector (<code>vec</code>) or <code>std::vector</code> of positive real numbers, and <code>a</code> has to to greater than or equal to zero.</li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>



	  <a name=mutual_info></a>
	  <b>mutual_info(A,dim) <br> 
	    mutual_info(A,subsys1,subsys2)<br> 
	    mutual_info(A,subsys1,subsys2,dim)</b><br><br>
	  <ul>
	    <li> Quantum mutual information between 2 subsystems of a quantum state.</li><br>
	    
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>

	    <li> In the first case, <code>dim</code> has to be a <code>uvec</code> of two elements, containing the dimensions of two subsystems.</li><br>

	    <li> In the second case, <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.
	      <code>subsys1</code> and <code>subsys1</code> are  <code>uvec</code> containing the indices of 1st party and 2nd party respectively.

	    </li><br>
	    <li> Indices in <code>subsys1</code> and <code>subsys2</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		
		cx_mat A = randn&lt;cx_mat&gt;(12,12); // 12x12 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		cx_mat B = randn&lt;cx_mat&gt;(16,16); // 16x16 matrix
		B *= B.t(); // make hermitian
		B /= trace(B); //normalise

		// mutual_info between two parties with dim 4 and 3
		double A1 = mutual_info(A,{4,3}); // 1st party has dim=4,
		// 2nd party has dim=3

		// mutual_info between 1,3 and 2,4 parties
		double B1 = mutual_info(B,{1,3},{2,4});

		double B2 = mutual_info(B,{1,3},{2,4},2); //same as above
		// all party has dim = 2

		double B1 = mutual_info(B,{1,3},{2,4},{2,2,2,2}); // explicitly writen 
		// dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>










	  <hr><br>




	  <a name=entanglement></a>
	  <b>entanglement(A,dim)</b><br><br>
	  <ul>
	    <li>Entanglement entropy of a pure quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>), and <code>dim</code> has to be a <code>uvec</code> of two elements, containing the dimensions of two subsystems..</li><br>
	    <li> If <code>A</code> is a square matrix and not a density matrix of a pure state, then von Neumann entropy of traced out 2nd party density matrix is returned. To make sure use <a href="#is_pure"><code>is_pure</code></a> function. </li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>




	  <a name=neg></a>
	  <b>neg(A,subsys) <br> neg(A,subsys,dim) </b><br><br>
	  <ul>
	    <li> Negativity of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices of transposed subsystems.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		cx_mat B = randn&lt;cx_mat&gt;(12,12); // 12x12 matrix
		B *= B.t(); // make hermitian
		B /= trace(B); //normalise

		// negativity by transposing 2nd and 3rd party
		double A1 = neg(A,{2,3}); // all dim are 2, total 3 parties

		// negativity by transposing 2nd and 3rd party
		double B1 = neg(B,{2,3},{2,3,2}); // explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>




	  <a name=log_neg></a>
	  <b>log_neg(A,subsys) <br> log_neg(A,subsys,dim) </b><br><br>
	  <ul>
	    <li> Logarithmic negativity of a quantum state, where <code>subsys</code> is a <code>uvec</code> containing the indices of transposed subsystems.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		cx_mat B = randn&lt;cx_mat&gt;(12,12); // 12x12 matrix
		B *= B.t(); // make hermitian
		B /= trace(B); //normalise

		// logarithmic negativity by transposing 2nd and 3rd party
		double A1 = log_neg(A,{2,3}); // all dim are 2, total 3 parties

		// logarithmic negativity by transposing 2nd and 3rd party
		double B1 = log_neg(B,{2,3},{2,3,2}); // explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>




	  <a name=concurrence></a>
	  <b>concurrence(A) </b><br><br>
	  <ul>
	    <li> Concurrence of a two-qubit quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) of dimension 4.</li>
	  </ul>
	  <a href="#top">Go to top</a>


	  <hr><br>


	  <a name=EoF></a>
	  <b>EoF(A) </b><br><br>
	  <ul>
	    <li> Entanglement of formation of a two-qubit quantum state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or column vector  (<code>vec</code> or <code>cx_vec</code>) of dimension 4.</li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name=ent_check_CMC></a>
	  <b>ent_check_CMC(A,dim) <br > ent_check_CMC(A,dim1,dim2) </b><br><br>
	  <ul>
	    <li> Check if a bipartite state is entangled or not (based on covariant matrix formulation).</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Returns <code>true</code> if <code>A</code> is entangled, else <code>false</code>. It also can detect large part of bound entangled states.</li><br>
	    <li> The first case assumes both the subsystems have same dimension. <code>dim</code> is an unsigned integer type stating the dimensions of both the subsystems.</li><br>
	    <li> The second case applies if the subsystems have different  dimensions. <code>dim1</code> and <code>dim2</code> are unsigned integer types stating the dimensions of 1st and 2nd parties respectively.</li>
	  </ul>
	  <a href="#top">Go to top</a>





	  <hr><br>


	  <a name=schmidt></a>
	  <b>vec S = schmidt(A,dim) <br > schmidt(A,dim,S,U,V) </b><br><br>
	  <ul>
	    <li> Schmidt decomposition of a bipartite pure state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> <code>dim</code> is a <code>uvec</code> of two elements, containing dimensions of each party.</li><br>
	    <li> <code>S</code> is a real vector containing Schmidt coefficients. <code>U</code> and <code>V</code> are matrices that store Schmidt vectors column-wise, such that <code>A = &Sigma;<sub>i</sub> S(i) * kron( U.col(i) , V.col(i) )</code>.</li><br>
	    <li> If <code>A</code> is a square matrix, then it is translated into a column vector using <a href=#conv_to_pure><code>conv_to_pure</code></a>.</li><br>
	    <li> If decomposition fails then <code>vec S = schmidt(A,dim)</code> throws <code>std::runtime_error exception</code>, and <code>schmidt(A,dim,S,U,V)</code> returns <code>false</code> and resets <code>S</code>, <code>U</code>, and <code>V</code>.</li><br>
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		vec S1 = schmidt(A,{2,4});

		vec S;
		cx_mat U,V;
		schmidt(A,{2,4},S,U,V);
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name=schmidt_base></a>
	  <b>schmidtA(A,dim) <br > schmidtA_full(A,dim) <br>
	    schmidtB(A,dim) <br > schmidtB_full(A,dim)<br>
	    schmidtAB(A,dim) <br > schmidtAB_full(A,dim)</b><br><br>
	  <ul>
	    <li> Schmidt vectors of a bipartite pure state.</li><br>
	    <li> <code>A</code> has to be a square matrix (<code>mat</code> or <code>cx_mat</code>) or column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> <code>dim</code> is a <code>uvec</code> of two elements, containing dimensions of each party.</li><br>
	    <li> If <code>A</code> is a square matrix, then it is translated into a column vector using <a href=#conv_to_pure><code>conv_to_pure</code></a>.</li><br>
	    
	    <li> <code>schmidtA(A,dim)</code> returns truncated Schmidt basis on Alice's side in a column-wise manner, while <code>schmidtA_full(A,dim)</code> returns full Schmidt basis on Alice's side.</li><br>
	    <li> <code>schmidtB(A,dim)</code> returns truncated Schmidt basis on Bob's side in a column-wise manner, while <code>schmidtB_full(A,dim)</code> returns full Schmidt basis on Bob's side.</li><br>
	    <li> <code>schmidtAB(A,dim)</code> returns <a href = "http://arma.sourceforge.net/docs.html#field"><code>field</code></a> of matrices containing truncated Schmidt basis on both sides in a column-wise manner, while <code>schmidtAB_full(A,dim)</code> returns <a href = "http://arma.sourceforge.net/docs.html#field"><code>field</code></a> of matrices containing full Schmidt basis on both side.</li><br>
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise
		
		cx_mat V = schmidtB(A,{2,4}); // V is 4x2 matrix
		
		cx_mat Vf = schmidtB_full(A,{2,4}); // Vf is 4x4 matrix

		field&lt;cx_mat&gt; AB = schmidtAB(A,{2,4});
		//AB(0) == Schmidt basis on Alice's side
		//AB(1) == Schmidt basis on Bob's side
	      </pre>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr><br>


	  <a name=HS_dist></a>
	  <b>HS_dist(A,B) </b><br><br>
	  <ul>
	    <li> Hilbert-Schmidt distance between two density matrices.</li><br>
	    <li> <code>A</code> and <code>B</code> have to be square matrices (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=tr_dist></a>
	  <b>tr_dist(A,B) </b><br><br>
	  <ul>
	    <li> Trace distance between two density matrices.</li><br>
	    <li> <code>A</code> and <code>B</code> have to be square matrices (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>


	  <a name=bures_dist></a>
	  <b>bures_dist(A,B) </b><br><br>
	  <ul>
	    <li> Bures distance between two density matrices.</li><br>
	    <li> <code>A</code> and <code>B</code> have to be square matrices (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>


	  <a name=fidelity></a>
	  <b>fidelity(A,B) </b><br><br>
	  <ul>
	    <li> Fidelity between two density matrices.</li><br>
	    <li> <code>A</code> and <code>B</code> have to be square matrices (<code>mat</code> or <code>cx_mat</code>) of same dimension.</li>
	  </ul>
	  <a href="#top">Go to top</a>




	  <hr><br>




	  <a name=apply></a>
	  <b>apply(A,U,subsys) <br> apply(A,U,subsys,dim) </b><br><br>
	  <ul>
	    <li>Apply a gate <code>U</code> to a quantum state <code>A</code>, where <code>subsys</code> is a <code>uvec</code> containing the indices of applicable subsystems.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> Dimension of gate <code>U</code> must match the dimension of subsystems specified in <code>subsys</code>.</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> Indices in <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		const cx_mat& U1 = states.S(1); // \sigma_x gate
		
		cx_mat U2 = kron(states.S(1),states.S(1)); 
		// kron(\sigma_x,\sigma_x) gate 

		cx_mat A1 = apply(A,U1,{2}); // all dim are 2, total 3 parties

		cx_mat A2 = apply(A,U2,{1,3},{2,2,2}); // explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><br>




	  <a name=apply_ctrl></a>
	  <b>apply_ctrl(A,U,ctrl,subsys) <br> apply_ctrl(A,U,ctrl,subsys,dim) </b><br><br>
	  <ul>
	    <li>Apply a controlled-gate <code>U</code> to a quantum state <code>A</code>, where <code>subsys</code> is a <code>uvec</code> containing the indices of applicable subsystems, and <code>ctrl</code> is a <code>uvec</code> containing the indices of control subsystems.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>) or a column vector (<code>vec</code> or <code>cx_vec</code>).</li><br>
	    <li> Dimension of gate <code>U</code> must match the dimension of subsystems specified in <code>subsys</code>.</li><br>
	    <li> All control subsystems must have same dimensions.</li><br>
	    <li> <code>dim</code> is optional. It can be either unsigned integer type or <code>uvec</code> containing dimensions of every subystem. When it is unsigned integer type, all sybsystems are supposed to have same dimensions (equal to <code>dim</code>). By default it is <i>2</i>. If different subsystems have different dimensions, use <code>dim</code> as a <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> Indices in <code>subsys</code> and <code>ctrl</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise

		const cx_mat& U1 = states.S(1); // \sigma_x gate
		
		cx_mat U2 = kron(states.S(1),states.S(1)); 
		// kron(\sigma_x,\sigma_x) gate 

		cx_mat A1 = apply_ctrl(A,U1,{1},{2}); // all dim are 2, total 3 parties

		cx_mat A2 = apply_ctrl(A,U2,{2},{1,3},{2,2,2}); 
		// explicitly writen dimensions
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>



	  <hr><hr>

	  <h3>Discord like functions</h3>
	  <hr> <br>




	  <a name="discord"></a>
	  <b>discord(A,subsys,dim)</b><br><br>
	  <ul>
	    <li>Quantum discord of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer type containing the index of measured subsystem.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qubit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>discord</code> returns a <code>vec</code>, where the first term is the value of quantum discord and 2nd and 3rd are optimized values of &theta; and &phi; respectively;</li><br>
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>
	    <li> <b>Helper functions:</b><br>
	      <code>discord</code> has various helper functions, to fine tune the result. All of these functions have local linkage.
	      <ul>
		<li> <code>void set_discord_global(bool a = true)</code> : Set whether global optimization will be performed (<code>true</code>) or not (<code>false</code>).</li><br>
		<li> <code>void set_discord_global_opt(nlopt::algorithm a = nlopt::GN_DIRECT_L)</code> : Set global optimization algorithm.</li><br>
		<li> <code>void set_discord_global_xtol(double a = 4e-2)</code> : Set global optimization <i>xtol</i>.</li><br>
		<li> <code>void set_discord_global_ftol(double a = 0)</code> : Set global optimization <i>ftol</i>.</li><br>

		<li> <code>void set_discord_local_opt(nlopt::algorithm a = nlopt::LN_COBYLA)</code> : Set local optimization algorithm.</li><br>
		<li> <code>void set_discord_local_xtol(double a = _precision::eps)</code> : Set local optimization <i>xtol</i>.</li><br>
		<li> <code>void set_discord_local_ftol(double a = 0)</code> : Set local optimization <i>ftol</i>.</li><br>

		<li> <code>void set_discord_theta_phi_range(double a = 1,double b = 2)</code>: Set &theta;-&phi; range as multiples of &pi;.</li><br>
		<li> <code>void set_discord_theta_phi_initial(double a = 0.1,double b = 0.1)</code>: Set inital &theta;-&phi; value as multiples of &pi;.</li><br>
		<li> <code>void set_discord_prob_tol(double a = _presicion::eps)</code>: Set floating point presicion for probability calculations.</li>
	      </ul>
	    </li><br>

	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise
		
		// change default global optimization algorithm
		set_discord_global_opt(nlopt::GN_DIRECT_L_RAND);

		// change default local optimization algorithm
		set_discord_local_opt(nlopt::LN_SBPLX);

		double disc = discord(A,2,{2,2,2})(0); // measurement is done 
		                                       //on 2nd party
		double theta = discord(A,2,{2,2,2})(1); //optimized theta value
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>









	  <hr> <br>




	  <a name="discord3"></a>
	  <b>discord3(A,subsys,dim)</b><br><br>
	  <ul>
	    <li>Quantum discord of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer type containing the index of measured subsystem.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qutrit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> <b>Helper functions:</b><br>
	      <code>discord3</code> has various helper functions, to fine tune the result. All of these functions have local linkage.
	      <ul>
		<li> <code>void set_discord3_global(bool a = true)</code> : Set whether global optimization will be performed (<code>true</code>) or not (<code>false</code>).</li><br>
		<li> <code>void set_discord3_global_opt(nlopt::algorithm a = nlopt::GN_DIRECT_L)</code> : Set global optimization algorithm.</li><br>
		<li> <code>void set_discord3_global_xtol(double a = 0.25)</code> : Set global optimization <i>xtol</i>.</li><br>
		<li> <code>void set_discord3_global_ftol(double a = 0)</code> : Set global optimization <i>ftol</i>.</li><br>

		<li> <code>void set_discord3_local_opt(nlopt::algorithm a = nlopt::LN_COBYLA)</code> : Set local optimization algorithm.</li><br>
		<li> <code>void set_discord3_local_xtol(double a = _precision::eps)</code> : Set local optimization <i>xtol</i>.</li><br>
		<li> <code>void set_discord3_local_ftol(double a = 0)</code> : Set local optimization <i>ftol</i>.</li><br>

		<li> <code>void set_discord3_angle_range(vec a = 2 * ones&lt;vec&gt;(5) )</code>: Set range of angles as multiples of &pi;.</li><br>
		<li> <code>void set_discord3_angle_initial(vec a = 0.1 * ones&lt;vec&gt;(5) )</code>: Set inital values of angles as multiples of &pi;.</li><br>
		<li> <code>void set_discord3_prob_tol(double a = _presicion::eps)</code>: Set floating point presicion for probability calculations.</li>
	      </ul>
	    </li><br>

	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(18,18); // 18x18 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise
		
		// change default global optimization algorithm
		set_discord3_global_opt(nlopt::GN_DIRECT_L_RAND);

		// change default local optimization algorithm
		set_discord3_local_opt(nlopt::LN_SBPLX);

		double disc = discord3(A,2,{2,3,3}); // measurement is done on 2nd party
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>






	  <hr> <br>






	  <a name=discord_reg></a>
	  <b>discord_reg(A,subsys,dim)</b><br><br>
	  <ul>
	    <li>Constrained regular quantum discord of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer type containing the index of measured subsystem. Here the measurement is only done in the eigenvectors of 3 spin matrices</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qubit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>discord_reg</code> returns a <code>vec</code>, where the 1st element is due to measurement on x direction, 2nd for measurement on y direction and 3rd for measurement on z direction. <code>min</code> of the returned <code>vec</code> is the actual constrained regular quantum discord.</li><br> 
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise
		
		vec disc = discord_reg(A,2,{2,2,2}); // measurement is done 
                                                     // on 2nd party

		double Cdisk = min(disk); // Constrained regular quantum discord
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>







	  <hr> <br>






	  <a name="discord3_reg"></a>
	  <b>discord3_reg(A,subsys,dim)</b><br><br>
	  <ul>
	    <li>Constrained regular quantum discord of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer type containing the index of measured subsystem. Here the measurement is only done in the eigenvectors of 3 spin matrices</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qutrit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>discord3_reg</code> returns a <code>vec</code>, where the 1st element is due to measurement on x direction, 2nd for measurement on y direction and 3rd for measurement on z direction. <code>min</code> of the returned <code>vec</code> is the actual constrained regular quantum discord.</li><br> 
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(18,18); // 18x18 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise
		
		vec disc = discord3_reg(A,2,{2,3,3}); // measurement is done 
                                                     // on 2nd party

		double Cdisk = min(disk); // Constrained regular quantum discord
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>


































	  <hr> <br>



	  <a name=deficit></a>
	  <b>deficit(A,subsys,dim)</b><br><br>
	  <ul>
	    <li>Quantum work deficit of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer type containing the index of measured subsystem.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qubit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>deficit</code> returns a <code>vec</code>, where the first term is the value of quantum work deficit and 2nd and 3rd are optimized values of &theta; and &phi; respectively;</li><br>
		    
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> <b>Helper functions:</b><br>
	      <code>deficit</code> has various helper functions, to fine tune the result. All of these functions have local linkage.
	      <ul>
		<li> <code>void set_deficit_global(bool a = true)</code> : Set whether global optimization will be performed (<code>true</code>) or not (<code>false</code>).</li><br>
		<li> <code>void set_deficit_global_opt(nlopt::algorithm a = nlopt::GN_DIRECT_L)</code> : Set global optimization algorithm.</li><br>
		<li> <code>void set_deficit_global_xtol(double a = 4e-2)</code> : Set global optimization <i>xtol</i>.</li><br>
		<li> <code>void set_deficit_global_ftol(double a = 0)</code> : Set global optimization <i>ftol</i>.</li><br>

		<li> <code>void set_deficit_local_opt(nlopt::algorithm a = nlopt::LN_COBYLA)</code> : Set local optimization algorithm.</li><br>
		<li> <code>void set_deficit_local_xtol(double a = _precision::eps)</code> : Set local optimization <i>xtol</i>.</li><br>
		<li> <code>void set_deficit_local_ftol(double a = 0)</code> : Set local optimization <i>ftol</i>.</li><br>

		<li> <code>void set_deficit_theta_phi_range(double a = 1,double b = 2)</code>: Set &theta;-&phi; range as multiples of &pi;.</li><br>
		<li> <code>void set_deficit_theta_phi_initial(double a = 0.1,double b = 0.1)</code>: Set inital &theta;-&phi; value as multiples of &pi;.</li><br>
		<li> <code>void set_deficit_prob_tol(double a = _presicion::eps)</code>: Set floating point presicion for probability calculations.</li>
	      </ul>
	    </li><br>

	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise
		
		// change default global optimization algorithm
		set_deficit_global_opt(nlopt::GN_DIRECT_L_RAND);

		// change default local optimization algorithm
		set_deficit_local_opt(nlopt::LN_SBPLX);

		double def = deficit(A,2,{2,2,2})(0); // measurement is done 
		                                      // on 2nd party
		double theta = deficit(A,2,{2,2,2})(1); // optimized theta value
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>









	  <hr> <br>




	  <a name=deficit3></a>
	  <b>deficit3(A,subsys,dim)</b><br><br>
	  <ul>
	    <li>Quantum work deficit of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer type containing the index of measured subsystem.</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qutrit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> <b>Helper functions:</b><br>
	      <code>deficit3</code> has various helper functions, to fine tune the result. All of these functions have local linkage.
	      <ul>
		<li> <code>void set_deficit3_global(bool a = true)</code> : Set whether global optimization will be performed (<code>true</code>) or not (<code>false</code>).</li><br>
		<li> <code>void set_deficit3_global_opt(nlopt::algorithm a = nlopt::GN_DIRECT_L)</code> : Set global optimization algorithm.</li><br>
		<li> <code>void set_deficit3_global_xtol(double a = 0.25)</code> : Set global optimization <i>xtol</i>.</li><br>
		<li> <code>void set_deficit3_global_ftol(double a = 0)</code> : Set global optimization <i>ftol</i>.</li><br>

		<li> <code>void set_deficit3_local_opt(nlopt::algorithm a = nlopt::LN_COBYLA)</code> : Set local optimization algorithm.</li><br>
		<li> <code>void set_deficit3_local_xtol(double a = _precision::eps)</code> : Set local optimization <i>xtol</i>.</li><br>
		<li> <code>void set_deficit3_local_ftol(double a = 0)</code> : Set local optimization <i>ftol</i>.</li><br>

		<li> <code>void set_deficit3_angle_range(vec a = 2 * ones&lt;vec&gt;(5) )</code>: Set range of angles as multiples of &pi;.</li><br>
		<li> <code>void set_deficit3_angle_initial(vec a = 0.1 * ones&lt;vec&gt;(5) )</code>: Set inital values of angles as multiples of &pi;.</li><br>
		<li> <code>void set_deficit3_prob_tol(double a = _presicion::eps)</code>: Set floating point presicion for probability calculations.</li>
	      </ul>
	    </li><br>

	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(18,18); // 18x18 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise
		
		// change default global optimization algorithm
		set_deficit3_global_opt(nlopt::GN_DIRECT_L_RAND);

		// change default local optimization algorithm
		set_deficit3_local_opt(nlopt::LN_SBPLX);

		double def = deficit3(A,2,{2,3,3}); // measurement is done on 2nd party
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>









	  <hr> <br>






	  <a name=deficit_reg></a>
	  <b>deficit_reg(A,subsys,dim)</b><br><br>
	  <ul>
	    <li>Constrained regular quantum work deficit of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer type containing the index of measured subsystem. Here the measurement is only done in the eigenvectors of 3 spin matrices</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qubit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>deficit_reg</code> returns a <code>vec</code>, where the 1st element is due to measurement on x direction, 2nd for measurement on y direction and 3rd for measurement on z direction. <code>min</code> of the returned <code>vec</code> is the actual constrained regular quantum work deficit.</li><br> 
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8); // 8x8 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise
		
		vec disc = deficit_reg(A,2,{2,2,2}); // measurement is done 
                                                     // on 2nd party

		double Cdisk = min(disk); // Constrained regular quantum work deficit
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>







	  <hr> <br>







	  <a name=deficit3_reg></a>
	  <b>deficit3_reg(A,subsys,dim)</b><br><br>
	  <ul>
	    <li>Constrained regular quantum work deficit of a quantum state <code>A</code>, where <code>subsys</code> is a unsigned integer type containing the index of measured subsystem. Here the measurement is only done in the eigenvectors of 3 spin matrices</li><br>
	    <li> <code>A</code> has be a square matrix (<code>mat</code> or <code>cx_mat</code>).</li><br>
	    <li> Measured subsystem has to be a qutrit system.</li><br>
	    <li> <code>dim</code> is a  <code>uvec</code> containing dimensions of every subystem.</li><br>
	    <li> <code>deficit3_reg</code> returns a <code>vec</code>, where the 1st element is due to measurement on x direction, 2nd for measurement on y direction and 3rd for measurement on z direction. <code>min</code> of the returned <code>vec</code> is the actual constrained regular quantum work deficit.</li><br> 
	    <li> Indices for <code>subsys</code> start from <i>1</i>, i.e., first party has the index <i>1</i>, second party has the index <i>2</i> and so on.</li><br>  
	    <li> Example:
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(18,18); // 18x18 matrix
		A *= A.t(); // make hermitian
		A /= trace(A); //normalise
		
		vec disc = deficit3_reg(A,2,{2,3,3}); // measurement is done 
                                                      // on 2nd party

		double Cdisk = min(disk); // Constrained regular quantum work deficit
	      </pre>
	    </li>
	  </ul>
	  <a href="#top">Go to top</a>












	  <hr><hr>
	  <a name=faq></a>
	  <h3>Frequently asked questions</h3>
	  <hr> <br>

	  <ul>
	 

	    <li> <b> What are the basic dependencies of QIC_lib?</b><br>
	      <ul>
		<li> <a href="http://arma.sourceforge.net/">Armadillo</a> C++ linear algebra library (version 4.2 or later), with  <a href = "http://www.netlib.org/lapack/">LAPACK</a> and 
		  <a href = "http://www.netlib.org/blas">BLAS</a> implementations.</li>
		<li> A C++11 compliant compiler. <a href="https://gcc.gnu.org/">gcc</a> version 4.8 or later, or <a href = "http://clang.llvm.org/">clang</a> version 3.3 or later are recommended. </li>
		<li>  <a href="http://ab-initio.mit.edu/wiki/index.php/NLopt">NLopt</a> nonlinear optimization library for certain features. See <a href ="index.html#getting-started"> getting started</a> section.
	      </ul>
	    </li>

	    <br>

	    
	    <li><b>How do I use QIC_lib?</b><br>
	      See <a href ="index.html#getting-started"> getting started</a> section.
	    </li>
	    
	    <br>


 
	    <li><b>How do I report bugs?</b><br>
	      See <a href="index.html#found-an-issue-or-bug">this</a>.
	    </li>
	    
	    <br>


	    <li><b>How do I use XYZ function properly?</b><br>
	      See <a href="#top">API documentation</a>. If you still have concerns, see <a href= "index.html#got-a-problem-or-question">this</a>.
	    </li>
	    
	    <br>


	    <li><b>Can you implement certain features, which are useful for my work?</b><br>
	      Yes, see <a href= "index.html#requesting-a-feature">this</a>.
	    </li>
	    
	    <br>


	 
	    

	    <li> <b> Instead of using other popular C++ linear algebra libraries, why did QIC_lib choose <a href="http://arma.sourceforge.net/">Armadillo</a>?</b>
	      <ul>
		<li> <a href="http://arma.sourceforge.net/">Armadillo</a> is fast, efficient and reliable.</li>
		<li> It has nice API, which is deliberately similar to Matlab.</li>
		<li> It supports modern C++11 features, like move semantics or initialiser list initialization, which indeed increase efficiency and usability.</li>
		<li> It has rapid developement process.</li>
		<li> It can make use of high performance  multi-threaded <a href = "http://www.netlib.org/lapack/">LAPACK</a> and 
		  <a href = "http://www.netlib.org/blas">BLAS</a> replacements like <a href = "http://www.openblas.net/">OpenBLAS</a>, <a href = "https://software.intel.com/en-us/intel-mkl">Intel MKL</a>, or <a href = "http://developer.amd.com/tools-and-sdks/archive/amd-core-math-library-acml/"> AMD ACML</a>.</li>
	      </ul>
	    </li>



	    <br>
    

	    <li><b>I know C++98, but do not know much about C++11. Can I use QIC_lib?</b><br>
	      Yes. Though QIC_lib is written in C++11 standard, you can still do C++98 style coding with QIC_lib functions. You just need a C++11 compliant compiler and make sure that you add necessary compiler flag to enable C++11 features, e.g., in <a href="https://gcc.gnu.org/">gcc</a> or <a href = "http://clang.llvm.org/">clang</a> add <code>-std=c++11</code> flag during compilation.
	    </li>
	



	    <br>

	    
	    <li><b>Can I use C++11 <code>auto</code> with QIC_lib functions?</b><br>
	      Though use of C++11 <code>auto</code> is not recommended with <a href="http://arma.sourceforge.net/">Armadillo</a> expressions, due to the extensive use of template meta-programming, every QIC_lib functions return by value, so use of <code>auto</code> is safe there. In fact, use of <code>auto</code> is recommended with QIC_lib functions and objects, as it will always guarantee <i>move</i> operations. But again, care should be taken when <code>auto</code> is used with <a href="http://arma.sourceforge.net/">Armadillo</a> expressions. See the following example:<br>
	      <pre>
		cx_mat A = randn&lt;cx_mat&gt;(8,8);
		A *= A.t();
		A /= trace(A);

		auto B = A; // OK, no temporary expression
		auto C = TrX(A,{1},{2,2,2}); // OK, QIC_lib function
		auto D = powm_sym(A,3); // OK, QIC_lib function

		auto E = A * A; // NOT OK!! temporary expression
		auto F = A + B + D ; // NOT OK!! temporary expression
		auto G = A * A.t(); // NOT OK!! temporary expression

		vec V = {0,1,2,3,4};

		for(auto&& i : V) // OK, no temporary exression
		{
		// do something
		}
		
		for(auto&& i : V+V) // NOT OK!! temporary expression
		{
		// do something
		}

		auto& S1 = states.S(1); // OK and recommended
		const cx_mat& S2 = states.S(2); // also OK  
		
	      </pre>
	    </li>


  
	    <li><b>Do QIC_lib uses C++14 features?</b><br>
	      No, only C++11 features have been used, since many compilers do not support C++14 fully. C++14 features like <i>auto return type deductions for functions</i> have been avoided by using template meta-programming.
	    </li>
	    
	    <br>



	  </ul>

	  <a href="#top">Go to top</a>



	  <hr><hr>
	  <a name=api_additions></a>
	  <h3>API Additions</h3>
	  <hr> <br>


	  <b>Version 0.0.3</b><br><br>
	  <ul>
	    <li> <a href=#dsum><code>dsum</code></a> and <a href=#dsum_pow><code>dsum_pow</code></a> added.</li>
	    <li> Fixed a bug in <a href=#tensor><code>tensor</code></a>.</li>
	  </ul>
	  <a href="#top">Go to top</a>

	  <hr><br>

	  <b>Version 0.0.2</b><br><br>
	  <ul>
	    <li> <a href=#absm><code>absm</code></a> added.</li>
	    <li> <a href=#schatten><code>schatten</code></a> added.</li>
	  </ul>
	  <a href="#top">Go to top</a>

	  <footer class="site-footer">
	    <span class="site-footer-owner"><a href="https://github.com/titaschanda/QIC_lib">Quantum Information and Computation library (QIC_lib)</a> is maintained by <a href="https://github.com/titaschanda">titaschanda</a>.</span>

	    <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
	  </footer>

    </section>


  </body>
</html>
